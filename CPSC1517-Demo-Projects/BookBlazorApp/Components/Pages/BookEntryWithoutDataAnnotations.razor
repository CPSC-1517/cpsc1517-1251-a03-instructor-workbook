@page "/book/entry1"
@using BookBlazorApp.ViewModels
@using Models
@inject IWebHostEnvironment WebHostEnvironment
@inject NavigationManager NavManager
@inject IJSRuntime JS

<h3>BookEntryWithoutDataAnnotations</h3>

@if (!string.IsNullOrWhiteSpace(feedbackMessage))
{
    <div class="alert alert-info">@feedbackMessage</div>
}

@* Provide EditContext to ValidationSummary/ValidationMessage without EditForm *@
<CascadingValue Value="editContext">
    <!-- Summary of all messages we add to the store -->
    <ValidationSummary />

    <div class="mb-3">
        <label for="title" class="form-label">Title:</label>
        <input id="title" class="form-control" 
            @bind="bookForm.Title" />
        <!-- Field-level messages for Title -->
        <ValidationMessage For="() => bookForm.Title" />
    </div>

    <div class="mb-3">
        <label for="pages" class="form-label">Pages:</label>
        <input id="pages" class="form-control" type="number"
               @bind="bookForm.Pages" />
        <!-- Field-level messages for Pages -->
        <ValidationMessage For="() => bookForm.Pages" />
    </div>

    <div class="mb-3">
        <label for="publishdate" class="form-label">Publish Date</label>
        <input id="publishdate" class="form-control" type="date"
               @bind="bookForm.PublishDate"
                />
        <!-- Field-level messages for PublishDate -->
        <ValidationMessage For="() => bookForm.PublishDate" />
    </div>

    <div class="mb-3">
        <label for="genre" class="form-label">Genre:</label>
        <select id="genre" class="form-control"
                @bind="bookForm.Genre"
                >
            @foreach (BookGenre genre in Enum.GetValues<BookGenre>().OrderBy(b => b.ToString()))
            {
                <option value="@genre">@genre</option>
            }
        </select>
        <!-- Field-level messages for Genre -->
        <ValidationMessage For="() => bookForm.Genre" />
    </div>

    <div class="mb-3 form-check">
        <input id="instock" type="checkbox" class="form-check-input"
               @bind="@bookForm.InStock" />
        <label class="form-check-label" for="instock">In Stock</label>
    </div>

    <!-- Not a submit button; just a regular click -->
    <button type="button" class="btn btn-primary" @onclick="AddBook">
        Add Book
    </button>
    <button type="button" class="btn btn-secondary" @onclick="ClearForm">
        Clear
    </button>
    <button type="button" class="btn btn-info" @onclick="NavigateToBookListing">
        Book Listing
    </button>
</CascadingValue>

@code {
    private string? feedbackMessage;
    // Model (no data annotations)
    private BookEntryForm bookForm = new();
    // Manual validation infrastructure
    private EditContext editContext = default!;
    private ValidationMessageStore? messageStore;

    protected override void OnInitialized()
    {
        editContext = new EditContext(bookForm);
        messageStore = new ValidationMessageStore(editContext);
    }

    private void AddBook()
    {
        messageStore!.Clear();
        feedbackMessage = null;

        // Title: required, 2–50
        if (string.IsNullOrWhiteSpace(bookForm.Title))
            messageStore!.Add(() => bookForm.Title, "Title is required");
        else if (bookForm.Title.Length < 2 || bookForm.Title.Length > 50)
            messageStore!.Add(() => bookForm.Title, "Title must be 2–50 characters");

        // Pages: >= 2
        if (bookForm.Pages < 2)
            messageStore!.Add(() => bookForm.Pages, "Pages must be ≥ 2");

        // PublishDate: past
        if (bookForm.PublishDate > DateOnly.FromDateTime(DateTime.Now))
            messageStore!.Add(() => bookForm.PublishDate, "PublishDate must to be in the past or present.");

        // If no messages, persist and reset
        if (!editContext.GetValidationMessages().Any())
        {
            try
            {
                string dataFolder = Path.Combine(WebHostEnvironment.ContentRootPath, "Data");
                Directory.CreateDirectory(dataFolder);

                string csvPath = Path.Combine(dataFolder, "books.csv");
                BookNoDataAnnotations bookModel = BookEntryForm.ToDomainModel(bookForm);
                File.AppendAllText(csvPath, bookModel.ToString() + Environment.NewLine);
                feedbackMessage = $"Successfully saved info to {csvPath}";

                bookForm = new();
                editContext = new EditContext(bookForm);
            }
            catch (Exception ex)
            {
                feedbackMessage = $"Failed to save file with exception {ex.Message}";
            }
            StateHasChanged();
        }
        else
        {
            feedbackMessage = "Fix the validation issues first.";
        }
    }

    private async void ClearForm()
    {
        // feedbackMessage = "ClearForm button clicked";
        bool confirmed = await JS.InvokeAsync<bool>("confirm", "Are you sure you want to clear this form and lose all changes??");
        if (confirmed)
        {
            bookForm = new();
            editContext = new EditContext(bookForm);
            feedbackMessage = "Form cleared.";
            StateHasChanged();
        }
        else
        {
            feedbackMessage = "Clear form canceled.";
            StateHasChanged();
        }

    }

    private async void NavigateToBookListing()
    {
        // feedbackMessage = "Book Listing button clicked";
        bool confirmed = await JS.InvokeAsync<bool>(
            "confirm",
            "Are you sure you want to navigate to the book listing page and lose all changes?");
        if (confirmed)
        {
            NavManager.NavigateTo("/books");
        }
        else
        {
            feedbackMessage = "Report navigation canceled.";
            StateHasChanged();
        }

    }
    
}
